## Что такое Event Loop?
Цикл событий (Event Loop) — это то, что позволяет Node.js выполнять 
неблокирующие операции ввода/вывода 
(несмотря на то, что JavaScript является однопоточным)
путем выгрузки операций в ядро системы, когда это возможно.

Поскольку большинство современных ядер являются многопоточными,
они могут обрабатывать несколько операций, выполняемых в фоновом режиме.
Когда одна из этих операций завершается, ядро сообщает Node.js,
что соответствующая этой операции функция обратного вызова 
(далее для простоты будет использован термин «коллбэк»)
может быть добавлена в очередь опроса, чтобы в конечном 
итоге быть выполненной.

## Фазы event loop
       ┌───────────────────────┐
    ┌─>│       таймеры         │
    │  └──────────┬────────────┘
    │  ┌──────────┴────────────┐
    │  │     I/O коллбэки      │
    │  └──────────┬────────────┘
    │  ┌──────────┴────────────┐
    │  │ ожидание, подготовка  │
    │  └──────────┬────────────┘      ┌───────────────┐
    │  ┌──────────┴────────────┐      │  входящие:    │
    │  │        опрос          │<─────┤  соединения,  │
    │  └──────────┬────────────┘      │  данные, итд. │
    │  ┌──────────┴────────────┐      └───────────────┘
    │  │      проверка         │
    │  └──────────┬────────────┘
    │  ┌──────────┴────────────┐
    └──┤    коллбэки `close`   │
       └───────────────────────┘

**1 фаза — таймеры**

Данная фаза выполняется непосредственно Event Loop'ом. 
Здесь просто обновляется время,
когда начал работать Event Loop.

Есть определённый стек, точнее, куча таймеров, 
это, по сути, то же самое, что очередь, 
где находятся таймеры. Берётся таймер с самым 
маленьким временем, сравнивается с текущим времени Event Loop'а, 
и, если настало время для исполнения данного таймера, 
выполняется его callback. Здесь стоит отметить что в
Node.js есть реализация setTimeout и есть setInterval. 
Для libuv это, по сути, одно и то же, только 
в setInterval ещё есть флаг repeat.

Соответственно, если у данного 
таймера стоит флаг repeat, то он снова помещается в 
очередь событий и потом точно так же обрабатывается.

Таймер определяет пороговое значение, п
осле которого может выполняться предоставленный коллбэк,
а не точное время, когда человек хочет его выполнить.
Коллбэки таймеров будут запущены так рано, как это возможно,
по истечении заданного времени, 
однако плановые работы операционной системы 
или выполнение других коллбэков могут задержать их.

**2 фаза — I/O-callback'и**

I/O коллбэки: выполняются почти все коллбэки, 
за исключением событий close, таймеров и setImmediate();

Здесь выполняются callback'и для неблокирующего ввода/вывода, 
т. е. это именно те функции, которые используются после запроса 
в базу данных или другой ресурс или на чтение/запись файла. 
Они выполняются именно на данной фазе.

**3 фаза — ожидание, подготовка**
Ожидание, подготовка: используется только для внутренних целей;

Это внутренние операции для callback'ов, 
по сути, мы не можем влиять на фазу, только косвенно. 
Есть process.nextTick, его callback может ненамеренно 
быть исполнен на фазе «ожидание, подготовка». 
process.nextTick выполняется на текущей фазе, т. е.,
по сути, process.nextTick может сработать абсолютно на любой фазе. 
Какого-то готового инструмента, 
чтобы запустить код на фазе «ожидание, подготовка», в Node.js нет.

**4 фаза — опрос**

Здесь выполняется весь наш код, который мы пишем на JS. 
Первоначально все запросы, которые мы делаем, попадают именно сюда,
и именно здесь Node.js может быть заблокирована. 
Если сюда попадёт какая-либо тяжёлая операция по вычислению, 
то на этом этапе наше приложение может просто зависнуть и ожидать,
пока не выполнится данная операция.

**5 фаза — проверка**

В Node.js есть таймер setImmediate,
его callback'и выполняются на этой фазе.

setImmediate() — это специальный таймер, который выполняется 
в отдельной фазе цикла событий. Он использует API libuv, 
чтобы запланировать коллбэки для выполнения после 
завершения фазы опроса.

**6 фаза (последняя) — callback'и событий close**

Если сокет или обработчик будет внезапно закрыт 
(например, socket.destroy()), на этой фазе будет
запущено событие 'close'. В ином случае оно будет 
запущено через process.nextTick().

## setImmediate() vs setTimeout()

setImmediate() и setTimeout() похожи, но ведут себя по-разному в том, когда они вызываются.

setImmediate() предназначен для выполнения сценария после завершения текущей фазы опроса.
setTimeout() планирует запуск сценария после истечения минимального порога в миллисекундах.